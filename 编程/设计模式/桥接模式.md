[TOC]

# 模式简介

- 将整体分离成不变的抽象部分与可变的实现部分，使它们可以相互独立。

桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。



# 桥接模式结构

桥接（Bridge）模式包含以下主要角色

- 抽象化角色（Abstraction）：定义抽象类，并包含一个对实现化对象的引用。
- 扩展抽象化角色（Refined Abstraction）：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
- 实现化角色（Implementor）：定义实现化角色的接口，供扩展抽象化角色调用。
- 具体实现化角色（Concrete Implementor）：给出实现化角色接口的具体实现。

![桥接模式的结构图](assets/3-1Q115125253H1.gif)



```cpp
// bridge.cpp 桥接模式
#include <iostream>
using namespace std;

//实现化角色：设备
class Driver
{
protected:
    string name = "";
    bool enable = false;
    uint volume = 10;
    uint channel = 1;

public:
    virtual string GetName() { return name; }

    virtual void Enable() { enable = true; }
    virtual void Disable() { enable = false; }
    virtual bool IsEnabled() { return enable; }

    virtual uint GetVolume() { return volume; }
    virtual void SetVolume(uint v) { volume = v; }

    virtual uint GetChannel() { return channel; }
    virtual void SetChannel(uint c) { channel = c; }
};

//具体实现化角色：电视机
class TV : public Driver
{
public:
    TV() { name = "TV"; }
};

//具体实现化角色：收音机
class Radio : public Driver
{
public:
    Radio() { name = "Radio"; }
};

//抽象化角色：遥控器
class RemoteControl
{
protected:
    Driver *driver;

public:
    RemoteControl(Driver *d) : driver(d) {}

    virtual string GetDriverName() { return driver->GetName(); }

    virtual void Enable() { driver->Enable(); }
    virtual void Disable() { driver->Disable(); }
    virtual bool IsEnabled() { return driver->IsEnabled(); }

    virtual uint GetVolume() { return driver->GetVolume(); }
    virtual void SetVolume(uint v) { driver->SetVolume(v); }

    virtual uint GetChannel() { return driver->GetChannel(); }
    virtual void SetChannel(uint c) { driver->SetChannel(c); }
};
//扩展抽象化角色：智能遥控
class AdvancedRemoteControl : public RemoteControl
{
public:
    AdvancedRemoteControl(Driver* d) : RemoteControl(d) {}
    string GetMute() { return "mute list"; }
};

void ClientCode(RemoteControl* rc)
{
    // ...
    cout << "Driver Name: " << rc->GetDriverName() << endl;
    std::cout << "\tIsEnabled: " << rc->IsEnabled() << endl;
    
    rc->Enable();
    std::cout << "\tEnable Driver." << endl;
    
    std::cout << "\tGetVolume: " << rc->GetVolume() << endl;
    std::cout << "\tGetChannel: " << rc->GetChannel() << endl;
    
    rc->SetVolume(66);
    rc->SetChannel(66);
    std::cout << "\tSetVolume(10) && SetChannel(10)"  << endl;

    std::cout << "\tGetVolume: " << rc->GetVolume() << endl;
    std::cout << "\tGetChannel: " << rc->GetChannel() << endl;
    // ...
}

int main()
{
    Driver *tv = new TV;
    Driver *radio = new Radio;

    RemoteControl *rc = new RemoteControl(radio);
    AdvancedRemoteControl *arc = new AdvancedRemoteControl(tv);

    ClientCode(rc);
    cout << endl;

    ClientCode(arc);
    cout << "\tGetMute: " << arc->GetMute() << endl;

    delete rc;
    delete arc;

    delete tv;
    delete radio;
    return 0;
}
```

```shell
[root@QingYun build]# ./bridge 
Driver Name: Radio
        IsEnabled: 0
        Enable Driver.
        GetVolume: 10
        GetChannel: 1
        SetVolume(10) && SetChannel(10)
        GetVolume: 66
        GetChannel: 66

Driver Name: TV
        IsEnabled: 0
        Enable Driver.
        GetVolume: 10
        GetChannel: 1
        SetVolume(10) && SetChannel(10)
        GetVolume: 66
        GetChannel: 66
        GetMute: mute list
```



> 问题：
>
> 如果抽象类中新增了一些属性，比如：Bag类中需要新增了大小，是否需要修改Bag类？如果需要修改，是否违背了开闭原则？如果需要修改，为什么不直接使用属性设置Bag的大小、颜色？





# 应用场景

- 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。
- 如果你希望在几个独立维度上扩展一个类， 可使用该模式。
-  如果你需要在运行时切换不同实现方法， 可使用桥接模式。





# 桥接模式优缺点

### 优点

- 抽象与实现分离，扩展能力强
- 符合开闭原则
- 符合合成复用原则
- 其实现细节对客户透明

### 缺点

- 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。



# 与其他模式的关系

- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， [适配器模式](https://refactoringguru.cn/design-patterns/adapter)通常在已有程序中使用， 让相互不兼容的类能很好地合作。
- [桥接](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
- 你可以将[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)和[桥接](https://refactoringguru.cn/design-patterns/bridge)搭配使用。 如果由*桥接*定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， *抽象工厂*可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
- 你可以结合使用[生成器模式](https://refactoringguru.cn/design-patterns/builder)和[桥接模式](https://refactoringguru.cn/design-patterns/bridge)： *主管*类负责抽象工作， 各种不同的*生成器*负责*实现*工作。