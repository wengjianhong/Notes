[TOC]

## 1. 内存分配

> 源码位置：zmalloc.c和zmalloc.h

zmalloc：主要封装内存分配和内存回收函数。

看这部分代码的时候第一个感受是抽像和封装真的很好，举个例子，zmalloc中和malloc相关的函数就有十个左右，我按照相互调用的关系重新排序和注释如下：

```cpp
static void zmalloc_default_oom(size_t size);         // 内存申请失败时的默认处理函数（print错误）
void *ztrymalloc_usable(size_t size, size_t *usable); // 调用malloc分配内存，usable为实际可用内存长度
void *ztrymalloc(size_t size);           // 申请内存（调用ztrymalloc_usable）,失败返回空指针
void *zmalloc(size_t size);              // 申请内存（调用ztrymalloc_usable，失败调用zmalloc_default_oom）
void *zmalloc_usable(size_t size, size_t *usable);   // 和zmalloc功能基本一致，只是多了[OUT] usable参数
size_t zmalloc_used_memory(void);        // 获取当前已用的内存大小（内部维护一个静态变量：used_memory）
void zmalloc_set_oom_handler(void (*oom_handler)(size_t));  // 设置自定义的 内存申请失败时的处理函数


size_t zmalloc_get_rss(void);    // 获取该任务当前驻留物理地址空间的大小RSS，/proc/<pid>/stat的第24个字段
int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);// 获取任务的分配内存、可用内存、常驻内存
size_t zmalloc_get_smap_bytes_by_field(char *field, long pid); // 从/proc/self/smaps获取pid的field字段的和
size_t zmalloc_get_private_dirty(long pid); //调用 zmalloc_get_smap_bytes_by_field("Private_Dirty", pid)
size_t zmalloc_get_memory_size(void);       // 调用系统函数，获取内存大小
void set_jemalloc_bg_thread(int enable);    // 空函数
int jemalloc_purge();                       // 空函数，直接返回0了
```

除此之外，还有一些释放和初始化的函数。

## 2. SDS动态字符串

> 源码位置：sds.h和sds.c

### 2.1 sds中包含5种不同长度的字符串：

```cpp
/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
// 可容纳最大的字符串长度2^5 = 32
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
// 可容纳最大的字符串长度2^8 = 256
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
// 可容纳最大的字符串长度2^16
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

> `struct __attribute__ ((__packed__))` 以紧凑的方式存储数据，取消字节对齐。
>
> #pragma pack (n)来指定数据结构的对齐值。



### 2.2 头文件中的一些内联函数：

```cpp
static inline size_t sdslen(const sds s);             // 获取len属性值
static inline size_t sdsavail(const sds s);           // 字符串剩余可用空间
static inline void sdssetlen(sds s, size_t newlen);   // 设置len属性值
static inline void sdsinclen(sds s, size_t inc);      // 字符串len属性值 + inc长度
static inline size_t sdsalloc(const sds s);           // 获取alloc属性值
static inline void sdssetalloc(sds s, size_t newlen); // 设置alloc属性值
```

> inline：
>
> 1. 可以使用inline函数完全取代表达式形式的宏定义
> 2. inline只是对编译器的建议，是否使用inline由编译器决定
> 3. inline函数的定义建议放在头文件中，保证函数可见和每个定义都是一样的
> 4. inline函数只适合简单函数，对于复杂的（循环、条件、递归）函数，inline函数不会生效
> 5. 定义在类声明中的成员函数默认都是内联的，在类外定义的函数要加上inline，否则认为不是内联
> 6. inline 是一种"用于实现的关键字"，仅在函数定义时候使用inline是不会生效的
>
> 慎用inline：
>
> 1. 内联能省去函数调用的开销，提高代码执行效率，但以代码膨胀（为代价），消耗更多的内存
>
> PS:
>
> - 定义在头文件中的内联函数可以再其他文件被调用到，定义在实现文件中的内联函数其他文件不可见。在sds中也有一些定义在c文件中的内联函数，比如sdsHdrSize，sdsReqType，sdsTypeMaxSize



### 2.3 一些常用的API函数

```cpp
sds sdsnewlen(const void *init, size_t initlen);    // 使用init初始化一个sds，初始长度为initlen
sds sdstrynewlen(const void *init, size_t initlen); // 和sdsnewlen基本一致，区别：失败不用调用失败处理函数
sds sdsnew(const char *init);                       // 使用init初始化一个sds
sds sdsempty(void);                                 // 调用 sdsnewlen("",0);
sds sdsdup(const sds s);                            // 复制一个sds
void sdsfree(sds s);                                // 释放sds
sds sdsgrowzero(sds s, size_t len);                 // sds增加len长度，并初始化为0
sds sdscatlen(sds s, const void *t, size_t len);    // 从t拼接长度为len的字符串
sds sdscat(sds s, const char *t);                   // 拼接C字符串t
sds sdscatsds(sds s, const sds t);                  // 拼接sds
sds sdscpylen(sds s, const char *t, size_t len);    // 将字符串t覆盖到sds对象s
sds sdscpy(sds s, const char *t);                   // 调用sdscpylen(s, t, strlen(t));

！！！以上的函数调用后，原来的sds对象不能再使用！！！
```



### 2.4 sds中的一些设计和实现

```cpp
typedef char *sds;
...
#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
...
static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];          // s指向sdshdr8的buf[]，所以s[-1]指向flag，详见下面分析
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}
```

上面的代码有一些设计巧妙的地方，第一次看的时候有点看的不是很懂，简单分析和记录一下：

**首先，关于SDS_HDR(T,s)的宏定义**

在`#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))`这句宏定义中，`##T`会被替换成变量`T`。

举个例子：上面的`sdslen(const sds s)`函数中，`SDS_HDR(8,s)`在宏转换后得到的是：`((struct sdshdr8 *)((s)-(sizeof(struct sdshdr8))))`。



**其次，关于sds的设计：**

从第一行可以看到sds是一个`char*`类型，而不是`sdshdr5`或者`sdshdr32`这类结构体指针。那么，这个`char*`指向哪里呢？

写一个简单的测试代码进行调试：

```cpp
#include <stdio.h>
#include <string.h>
#include "../../src/sds.h"
#include "../../src/sds.c"
#include "../../src/zmalloc.h"
#include "../../src/zmalloc.c"

int main(){
    char * data = "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS";
    int len = strlen(data);

    sds t = sdsnewlen(data, len);
    printf("%s\n", t);
}
```

通过cgdb跟进去之后看到，我们一直在用的`sds`，即`char*`的`s`，指向的是`sdshdr8`中的`buf[]` ：

![image-20210821190518600](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210821190518600.png)

又因为，上述的结构体定义中都用来`__attribute__ ((__packed__)) `，所以，`unsigned char flags = s[-1];`指向的是结构体的`flags`。

另外，在看下`SDS_HDR(T,s)`的宏定义，`((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))`在上面的例子中，会被转换成`((struct sdshdr8 *)((s)-(sizeof(struct sdshdr8))))`，我们知道`s`指向`buf[]`，所以，`(s)-(sizeof(struct sdshdr8))`指向`sdshdr8`结构体的首个位置，即`(struct sdshdr8 *)`。因此，我们可以在sds的代码中看到很多类似`SDS_HDR(64,s)->len`的用法。



## 3. 双端链表

> 源码位置：adlist.c和adlist.h

### 3.1 数据结构

```cpp
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```

### 3.2 一些宏函数定义

```cpp
/* Functions implemented as macros */
#define listLength(l) ((l)->len)                      // 链表长度
#define listFirst(l) ((l)->head)                      // 链表头元素
#define listLast(l) ((l)->tail)                       // 链表尾元素
#define listPrevNode(n) ((n)->prev)                   // 上一个元素
#define listNextNode(n) ((n)->next)                   // 下一个元素
#define listNodeValue(n) ((n)->value)                 // 结点值

#define listSetDupMethod(l,m) ((l)->dup = (m))        // 设置自定义的拷贝方法
#define listSetFreeMethod(l,m) ((l)->free = (m))      // 设置自定义释放方法
#define listSetMatchMethod(l,m) ((l)->match = (m))    // 设置自定义值比较方法

#define listGetDupMethod(l) ((l)->dup)                // 获取自定义的拷贝方法
#define listGetFreeMethod(l) ((l)->free)              // 获取自定义释放方法
#define listGetMatchMethod(l) ((l)->match)            // 获取自定义值比较方法
```

> 一种很有借鉴意义的实现方法，可以减少了函数调用的开销



### 3.3 API函数

```cpp
/* Prototypes */
list *listCreate(void);
void listRelease(list *list);
void listEmpty(list *list);
list *listAddNodeHead(list *list, void *value);
list *listAddNodeTail(list *list, void *value);
list *listInsertNode(list *list, listNode *old_node, void *value, int after);
void listDelNode(list *list, listNode *node);

listIter *listGetIterator(list *list, int direction);     // 获取迭代器
listNode *listNext(listIter *iter);                       // 获取下一个迭代器
void listReleaseIterator(listIter *iter);                 // 释放迭代器

list *listDup(list *orig);
listNode *listSearchKey(list *list, void *key);
listNode *listIndex(list *list, long index);
void listRewind(list *list, listIter *li);
void listRewindTail(list *list, listIter *li);
void listRotateTailToHead(list *list);
void listRotateHeadToTail(list *list);
void listJoin(list *l, list *o);
```

和双链表相关的函数都比较简单，不做过多说明。主要说下这里的迭代器的实现。

因为双链表本身支持获取上一个元素、下一个元素，所以在双链表中的迭代器直接基于双链表实现的。从`3.1 数据结构`部分也可以看出，迭代器的定义中包含的是`listNode`类型的成员变量



## 4. 字典

> dict.h和dict.c
>
> redis中的字典使用Hash表实现，其中hash表每个节点又是一个链表

### 4.1 数据结构

```cpp
// 字典节点
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next; // 指向下一个节点
} dictEntry;

// 定义字典节点的hash计算、节点比较、销毁、拷贝等函数
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
} dictType;

/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;        // 节点指针的指针（节点指针数组的指针）
    unsigned long size;       // Hash表大小
    unsigned long sizemask;   // 掩码 sizemask = size - 1，用于计算索引值
    unsigned long used;       // 已使用的大小
} dictht;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];        // 因为Hash表增长之后需要做Hash的迁移，所以需要新旧两个Hash表
    long rehashidx;      // rehashidx==-1，没有在rehash；rehashidx>=0，rehash到hash表中的rehashidx位置
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
} dict;

/* If safe is set to 1 this is a safe iterator, that means, you can call
 * dictAdd, dictFind, and other functions against the dictionary even while
 * iterating. Otherwise it is a non safe iterator, and only dictNext()
 * should be called while iterating. */
typedef struct dictIterator {
    dict *d;
    int safe;                      // 值为1时，构造迭代器d->pauserehash++，释放迭代器d->pauserehash--
    int table;                     // d->ht[]有两个hash表，table表示当前的要用的hash表下标(0/1)
    long index;                    // 迭代器指向的hash表中的下标
    dictEntry *entry, *nextEntry;  // entry:当前指向的节点，nextEntry：下一个节点
    /* unsafe iterator fingerprint for misuse detection. */
    long long fingerprint;         // 迭代器指纹，如果发生rehash或者插入删除都会导致指纹不一致
} dictIterator;
```

### 4.2 设计说明

![image-20210825204500072](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210825204500072-16298955027801.png)

> 如图所示，字典（hash表）的结构简单描述如下
>
> `dict`表示一个字典的数据结构，字典中有两个`hash表`（ht0，ht1）。一般情况下只用ht0，只有进行hash表扩容的时候用到ht1，扩容结束后把ht1挪到ht0，继续使用ht0。
>
> `hash表`是一个dictEntry指针数组，而`dictEntry`又可以当做列表节点，所以`hash表`中的每个元素又是一个`链表`（一般也叫桶: bucket）———— 之所以每个节点是一个桶而不是一个简单的节点，目的是为了解决hash冲突问题，详见`4.3`



### 4.3 API函数

```cpp
// =========== 字典操作
dict *dictCreate(dictType *type, void *privDataPtr);    // 创建hash表
int dictExpand(dict *d, unsigned long size);            // 扩展hash表为2*size（成功：返回0，失败：返回1）
int dictTryExpand(dict *d, unsigned long size);         // 和dictExpand差不多，失败不会提示
int dictAdd(dict *d, void *key, void *val);             // 添加键值对（成功：0，失败：1）
dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing); // 添加键的底层实现，如果键已存在则失败
dictEntry *dictAddOrFind(dict *d, void *key);       // 若key不存在插入新节点，若key存在返回已存在的字典节点
int dictReplace(dict *d, void *key, void *val);     // 若key不存在插入新节点，若key存在节点中的值替换成val
int dictDelete(dict *d, const void *key);           // 删除一个节点，成功：0，失败：-1，
dictEntry *dictUnlink(dict *ht, const void *key);   // 摘除一个节点，并返回摘除的节点，节点不存在返回NULL
void dictFreeUnlinkedEntry(dict *d, dictEntry *he); // 释放已摘除的节点
void dictRelease(dict *d);                          // 释放一个hash表
dictEntry *dictFind(dict *d, const void *key);      // 查找节点
void *dictFetchValue(dict *d, const void *key);     // dictFind节点，并获取val
int dictResize(dict *d);                            // hash表调整为used的两倍大小
void dictEmpty(dict *d, void(callback)(void*));     // 清空并销毁字典
dictEntry *dictGetRandomKey(dict *d);               // 获得一个随机节点（先获得随机一个桶，再拿桶内随机节点）
dictEntry *dictGetFairRandomKey(dict *d);           // 获得更加随机的一个节点（对dictGetRandomKey稍微优化）
unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count); // 随机获取count个节点
dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash); // 用旧指针和hash值查找节点

// =========== 迭代器
dictIterator *dictGetIterator(dict *d);             // 获得初始化的迭代器
dictIterator *dictGetSafeIterator(dict *d);         // 底层调用dictGetIterator(d),  safe赋值为1
dictEntry *dictNext(dictIterator *iter);            // 根据迭代器，获得下一个节点
void dictReleaseIterator(dictIterator *iter);       // 释放迭代器，如果safe==1，pauserehash--

// =========== Hash
uint64_t dictGetHash(dict *d, const void *key);                      // 获取hashkey
void dictSetHashFunctionSeed(uint8_t *seed);                         // 设置hash种子
uint8_t *dictGetHashFunctionSeed(void);                              // 获取hash种子
uint64_t dictGenHashFunction(const void *key, int len);              // 生成hashkey，默认是siphash
uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len); // 生成hashkey，使用siphash_nocase
void dictEnableResize(void);                                         // 允许hash表重新调整hash表大小
void dictDisableResize(void);                                        // 不允许所有hash表重新调整hash表大小
void dictGetStats(char *buf, size_t bufsize, dict *d);               // hash表中的一些统计信息（调试用）
// =========== Rehash
int dictRehash(dict *d, int n);                       // rehash表中的n个节点
int dictRehashMilliseconds(dict *d, int ms);          // rehash运行ms毫秒（rehash 100个节点判断一次时间）

// =========== Debug
unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, void *privdata);                                      // 扫描hash表，对节点执行fn函数，对桶执行bucketfn函数
```



### 4.4 Hash冲突

在哈希表实现中，当两个不同的键拥有相同的哈希值时，称这两个键发生`碰撞（collision）`

Redis的字典哈希表所使用的碰撞解决方法被称之为`链地址法`.

假设现在有一个带有三个节点的哈希表，如下图：

![image-20210825210715421](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210825210715421.png)



对于一个新的键值对`key4`和`value4`，如果`key4`的哈希值和`key1`的哈希值相同，那么它们将在哈希表的`0`号索引上发生碰撞。

`链地址法`通过将 `key4-value4` 和 `key1-value1` 两个键值对用链表连接起来，就可以解决碰撞的问题。

![image-20210825210349959](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210825210349959.png)



### 4.5 渐进式Hash

在Redis的Hash表实现中，Hash表初始大小默认为4.

但是，随着字典中不断插入新的键值对后，hash表中的元素也不断增加，产生`Hash冲突（碰撞collision）`的概率也越来越大，从而大大降低索引的效率。所以，这个时候就必须对Hash表进行扩展————增加hash表长度，并且重新索引键值对。

Hash表扩展的两个重要问题：

- 什么时候扩容（相对应的也要有缩容）

    > 在Redis的Hash表的实现的数据结构`dictht`中，有两个字段size和used，分别表示Hash表的大小和已经使用的大小。
    >
    > 哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的使用程度，一定程度上也可以体现查询的效率，计算公式为:负载因子 = 总键值对数/箱子个数 = used/size
    >
    > Redis中当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩容为当前size的`两倍`： 
    >
    > 1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。 2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。
    >
    > 另外，当哈希表负载因子小于0.1时，程序自动开始对哈希表执行收缩为当前size的`1/2`。

- 如何在不影响服务的情况下进行扩容

    > Redis扩容主要通过两个函数实现`dictRehash(dict *d, int n)`和`dictRehashMilliseconds(dict *d, int ms)`(函数功能参看`4.2API函数`)。
    >
    > 另外，为了不影响服务，rehash动作并不是一次性、集中式完成的，而是分多次、渐进式的完成：
    >
    > 1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
    >
    > 2. 在字典中维持一个索引计数器变量rehashidx，并将它置为0，表示rehash工作开始。
    > 3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]中，当rehash工作完成之后，程序将rehashidx属性的值+1。
    > 4. 程序会在空闲的时候，创建一个rehash线程，并且调用`dictRehashMilliseconds(d, 1)`和`dictRehash(d, 100)`进行rehash，具体过程为：每次rehash开始先计时，从rehash表中的取100个节点进行rehash，完成100个节点后判断是否总用时超过1ms，如果超过则停止等待下次，没有超过则继续rehash。
    > 5. 随着字典操作的不断进行，最终在某个时间点上，ht[0]的所有键值对都被rehash到ht[1]上，这时将rehashidx属性设为-1，表示rehash完成。



### 4.7 迭代器



### 4.8 字典的增删改查

- 增：调用`dictAdd`，时间复杂度`O(1)`

- 删：先查找和摘除节点，再调用`dictFreeUnlinkedEntry`释放节点，时间复杂度`O(1)`

- 改：调用`dictReplace`，替换节点中的值，时间复杂度`O(1)`

- 查：`dictFind`，时间复杂度`O(1)`

### 4.9 一些疑问

> dictGetRandomKey:在这个函数的实现中，看着是每次随机生成一个hashkey，然后如果该key对应的桶不为空，从中取一个节点；为空，继续随机生成hashkey。有个疑问：如果hash表有比较多的空桶，那不是要随机生成很多次hashkey才能找到有值的桶？

## 5. 跳跃表

> zskiplist没有单独的头文件和c文件，其中
>
> 关于zskiplist结构和zskiplistNode结构定义在server.h文件里面
>
> 函数实现在t_zset.c中的所有zsl开头的函数，比如zslCreate、zslInsert、zslDeleteNode等。

### 5.1 数据结构

```cpp
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {             // 跳跃表节点
    sds ele;                               // 节点值
    double score;                          // 分值，跳跃表中根据分值排序
    struct zskiplistNode *backward;        // 后退指针：指向上一个节点
    struct zskiplistLevel {                // 跳跃表层次（）
        struct zskiplistNode *forward;     // 前进指针：指向 *当前层次* 下一个节点
        unsigned long span;                // 跨度：从当前节点到forward节点之间的节点个数（前闭后开）
    } level[];                             // 层次数组
} zskiplistNode;

typedef struct zskiplist {                 // 跳跃表
    struct zskiplistNode *header, *tail;   // 跳跃表的头结点、尾结点
    unsigned long length;                  // 跳跃表总节点个数
    int level;                             // 跳跃表最大层次
} zskiplist;

typedef struct zset {                      // 有序集合
    dict *dict;                            // 
    zskiplist *zsl;                        // 
} zset;
```

> zskiplist在redis中不是一个独立存在的数据结构，不能像list或者dict一样通过redis提供的指令或者API函数进行创建和使用。skiplist只在redis的内部和底层使用，并且只在两个地方用到跳跃表：
>
> - 一个是实现有序集合
> - 一个是在集群节点中用作内部数据结构

### 5.2 API函数

```cpp
zskiplist *zslCreate(void);                                       // 创建和初始化跳跃表
void zslFree(zskiplist *zsl);                                     // 释放跳跃表及其节点
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);  // 插入一个节点，详见下面说明
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node); // 摘除节点，不释放
zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range); // 获取range范围内的第一个节点（按照score排序）
zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);  // 获取range范围内的最后一个节点（按照score排序）
unsigned long zslGetRank(zskiplist *zsl, double score, sds o);     // 查找分值=score、数据=o节点的位置
zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range); // 获取range范围内的第一个节点（按照ele排序）
zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);  // 获取range范围内的最后一个节点（按照ele排序）
```

> 疑问：
>
> - score怎么得到的
> - zslFirstInLexRange和zslLastInLexRange函数是按照ele查找元素，跳跃表按照score排序，怎么算

### 5.3 设计说明

![image-20210827194536298](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210827194536298.png)

> 如图所示，zskiplist表示跳跃表节点，包含：
>
> - *header：指向跳跃表head节点
> - *tail：指向跳跃表最后一个节点
> - length：跳跃表的节点个数
> - level：跳跃表最大的有效层次
>
> 跳跃表的header节点
>
> - 不存储数据，ele、socore和backward没有被使用到
> - 用来索引其他节点，header节点的层次（level[]的长度）始终设为最大长度（32）
>
> 跳跃表的数据节点：
>
> - 数据节点的层次（level[]长度）随机设置为1~32，层次越大概率指数降低
> - 数据节点按照score升序排序，若score相等，则按照ele升序排序
> - backward指向前面一个节点
> - level[x].forward指向下一个level[x]节点
> - level[x].span表示当前节点，到下一个level[x]节点的距离（前开后闭）



#### 5.3.1 插入节点

假设要向上图的跳跃表中插入一个（score=6, ele="k"）节点：

1. 查找插入的位置，并记录新节点在每层中的前置节点

- 从跳跃表最高层次的level开始找
- 如果下个节点的score较小或者score相同ele较小，则向前一个节点，否则向下一个层次

> 以上图插入一个（score=6, ele="k"）节点为例，查找过程：
>
> - `level[4]`:header节点->(score=7, ele="i")失败：下降到`level[3]`
>
> - `level[3]`:header节点->(score=3, ele="c")成功->(score=7, ele="i")失败：下降到`level[2]`
> - `level[2]`:(score=3, ele="c")->(score=7, ele="i")失败：下降到`level[1]`
> - `level[1]`:(score=3, ele="c")->(score=5, ele="d")成功->(score=7, ele="i")失败：下降到`level[0]`
> - `level[0]`:(score=5, ele="d")->(score=7, ele="i")失败->结束

2. 插入节点

- 生成新节点，新节点的层次为1~32的随机值nlevel（层次越高，概率指数下降）
- 如果nlevel > 跳跃表level，更新跳跃表level
- 从最低的1层起到level，逐层往上插入更新节点

**复杂度分析**

> 时间复杂度：
>
> - 查找节点，假设跳跃表层次即`l`。
>     $$
>     O(size/2^l + size/2^l/2^{(l-1)} + .. +  + size/2^l/2^{(l-1)}/.../2^0 + size)
>     $$
>
> - 插入节点：插入次数为层次`l`
>
>     又`l=log2(size)`，综上，时间复杂度约为：`O（logN）`
>
> 空间复杂度：记录新节点在每层的前置节点数组长度：ZSKIPLIST_MAXLEVEL，O(1)



## 6. 快表

> 源码位置：quicklist.h 和 quicklist.c

### 6.1 数据结构

```cpp
// 表节点
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;
    unsigned int sz;                     /* ziplist size in bytes */
    unsigned int count : 16;             /* count of items in ziplist */
    unsigned int encoding : 2;           /* RAW==1 or LZF==2 */
    unsigned int container : 2;          /* NONE==1 or ZIPLIST==2 */
    unsigned int recompress : 1;         /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int extra : 10;             /* more bits to steal for future usage */
} quicklistNode;

// 快表结构
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;                  /* total count of all entries in all ziplists */
    unsigned long len;                    /* number of quicklistNodes */
    int fill : QL_FILL_BITS;              /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;
```



![在这里插入图片描述](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW5jYWlvbmU=,size_16,color_FFFFFF,t_70.png)

插入和新增节点





## 7. 基数统计

> 源码位置：hyperloglog.c 中的 hllhdr 结构， 以及所有以 hll 开头的函数

Redis中hyperloglog是用来做基数统计的，其优点是：在输入元素的数量或者体积非常非常大的时候，计算基数所需的空间总是固定的，并且是很小的。在Redis里面，每个Hyperloglog键只需要12Kb的大小就能计算接近2^64个不同元素的基数，但是hyperloglog只会根据输入元素来计算基数，而不会存储元素本身，所以不能像集合那样返回各个元素本身。

### 7.1 基数统计介绍

什么是基数呢？基数是指一个集合中不同元素的个数。假设有一组数据{1,2,3,4,5,6}，除去重复的数字之后，该组数据中不同的数有6个，则该组数据的基数为6。

那什么是基数统计呢？基数统计是指在误差允许的情况下估算出一组数据的误差。

从上述的概念中，我们可以很容易想到基数统计的用途，假设需要计算出某个网站一天中的独立ip访问量，相同ip访问多次的话值算作一次。这个问题即可转换成求一天内所有访问该网站的ip数组的基数。关键在于如何求这个基数？下面我就以最易懂的方法来给大家讲一下。

### 7.2 算法思路

#### 7.2.1 伯努利过程

投掷一次硬币出现正、反两面的概率均为`1/2`。如果我们不断的投掷硬币，直到出现一次正面，在这样的一个过程中，投掷一次得到正面的概率为`1/2`，投掷两次才得到正面的概率为`1/2^2`...依次类推，投掷k次才得到一次正面的概率为`1/(2^k)`。这个过程在统计学上称为伯努利问题。

有了以上的分析后，我们继续来思考下面两个问题：

- 进行n次伯努利过程，所有投掷次数都小于k的概率
- 进行n次伯努利过程，所有投掷次数都大于k的概率

针对第一个问题，在一次伯努利过程中，投掷次数大于k的概率为`1/(2^k)`，也就是投了k次反面的概率。因此，在一次过程中投掷次数不大于k的概率为`1-1/(2^k)`。因此n次伯努利过程所有投掷次数都不大于k的概率为:

![image-20210902074752169](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210902074752169.png)

很显然，第二个问题，n次伯努利过程，所有投掷次数都不小于k的概率为

![image-20210902074717883](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210902074717883.png)

从上述公式中可得出结论：当n远小于`2^k`时，![image-20210902074857452](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210902074857452.png)几乎为0，即所有投掷次数都小于k；当n远大于`2^k`时，![image-20210902074933717](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210902074933717.png)几乎为0，即所有投掷次数都大于k。因此，当x=k的情况下，我们可以把`2^k`当成n的一个粗糙估计。

### 7.3 基数统计

将上述伯努利过程转换到比特位串上，假设我们有8位比特位串，每一位上出现0或者1的概率均为1/2，投掷k次才得到一次正面的过程可以理解为第k位上出现第一个1的过程。

那么针对一个数据集来说，我们用某种变换将其转换成一个比特子串，就可以根据上述理论来估算出该数据集的技术。例如数据集转换成00001111，第一次出现1的位置为4，那么该数据集的基数为16。

于是现在的问题就是如何将数据集转换成一个比特位串？很明显，哈希变换可以帮助我们解决这个问题。

选取一个哈希函数，该函数满足一下条件：

- 具有很好的均匀性，无论原始数据集分布如何，其哈希值几乎服从均匀分布。这就保证了伯努利过程中的概率均为1/2
- 碰撞几乎忽略不计，也就是说，对于不同的原始值，其哈希结果相同的概率几乎为0
- 哈希得出的结果比特位数是固定的。

有了以上这些条件，就可以保证”伯努利过程“的随机性和均匀分布了。

接下来，对于某个数据集，其基数为n，将其中的每一个元素都进行上述的哈希变换，这样就得到了一组固定长度的比特位串，设`f(i)`为第i个元素比特位上第一次出现”1“的位置，简单的取其最大值`f(max)`为`f(i)`的最大值，这样，我们就可以得出以下结论：

- 当n远小于`2^f(max)`时,`f(max)`为当前值的概率为0
- 当n远大于`2^f(max)`时，`f(max)`为当前值的概率为0

这样一来，我们就可以将`2^f(max)`作为n的一个粗糙估计。当然，在实际应用中，由于数据存在偶然性，会导致估计量误差较大，这时候需要采用分组估计来消除误差，并且进行偏差修正。

所谓分组估计就是，每一个数据进行hash之后存放在不同的桶中，然后计算每一个桶的`f(max)`，最后对这些值求一个平均`f(avg)`，即可得到基数的粗糙估计`2^f(avg)`。

### 7.4 Redis之hyperloglog实现

#### 7.4.1 数据结构

每个hyperloglog键由一下结构体组成：

```cpp
struct hllhdr {
    char magic[4];        // 固定‘HYLL’，用于标识hyperloglog键
    uint8_t encoding;     // 编码模式，有密集标识Dence和稀疏模式sparse
    uint8_t notused[3];   // 未使用字段，留着日后用
    uint8_t card[8];      // 基数缓存，存储上一次计算的基数
    uint8_t registers[];  // 桶个数，用来存放数据，Redis中大小为16384
};
```

#### 7.4.2 添加元素

Redis提供一下命令来向hyperloglog键中添加数据。

```cpp
PFADD key element [element ...]
```

其源码实现如下：

```cpp
void pfaddCommand(client *c) {
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    struct hllhdr *hdr;
    int updated = 0, j;
    // 客户端交互部分，此处可以放着以后理解
    if (o == NULL) { 
        // 创建一个hyperloglog键
        o = createHLLObject();
        dbAdd(c->db,c->argv[1],o);
        updated++;
    } else {
        // 判断是否是一个hyperloglog键，判断前四个字节是否为'HYLL'
        if (isHLLObjectOrReply(c,o) != C_OK) return;
        o = dbUnshareStringValue(c->db,c->argv[1],o);
    }
    // 调用hllAdd函数来添加元素
    for (j = 2; j < c->argc; j++) {
        int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
                               sdslen(c->argv[j]->ptr));
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            addReplySds(c,sdsnew(invalid_hll_err));
            return;
        }
    }
    hdr = o->ptr;
    if (updated) {
        signalModifiedKey(c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
        server.dirty++;
        HLL_INVALIDATE_CACHE(hdr);
    }
    // 客户端交互部分，此处可以放着以后理解
    addReply(c, updated ? shared.cone : shared.czero);
}
```

上述代码包含了很多与客户端交互的部分，此处可以先不看，添加元素主要由hllAdd函数实现。

```cpp
int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
    struct hllhdr *hdr = o->ptr;
    switch(hdr->encoding) {
    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);  // 密集模式添加元素
    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize); // 稀疏模式添加元素
    default: return -1; // 非法模式
    }
}
```

以hllDenseAdd为例，首先计算待添加元素的第一次出现“1”的位置count和该元素添加到第index个桶内，然后查看registers部分，第index个桶内此时存放的第一次出现“1”的最大的位数oldcount，比较oldcount和count，如果前者大，则不处理；如果后者大，更新oldcount为count。

```cpp
// 密集模式添加元素
int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
    uint8_t oldcount, count;
    long index;

    // 计算该元素第一个1出现的位置
    count = hllPatLen(ele,elesize,&index);
    // 得到第index个桶内的count值
    HLL_DENSE_GET_REGISTER(oldcount,registers,index);
    if (count > oldcount) {
        // 如果比现有的最大值还大，则添加该值到数据部分
        HLL_DENSE_SET_REGISTER(registers,index,count);
        return 1;
    } else {
        // 如果小于现有的最大值，则不做处理，因为不影响基数
        return 0;
    }
}
// 用于计算hash后的值中，第一个出现1的位置
int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
    uint64_t hash, bit, index;
    int count;
    // 利用MurmurHash64A哈希函数来计算该元素的hash值
    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);
    // 计算应该放在哪个桶
    index = hash & HLL_P_MASK;
    // 为了保证循环能够终止
    hash |= ((uint64_t)1<<63); 
    bit = HLL_REGISTERS;
    // 存储第一个1出现的位置
    count = 1;
    // 计算count
    while((hash & bit) == 0) {
        count++;
        bit <<= 1;
    }
    *regp = (int) index;
    return count;
}
```

#### 7.4.3 计算基数

Redis提供了下面的命令来计算数据集的基数。

```cpp
PFCOUNT key [key ...]
```

如果只有一个key则计算其基数即可；如果存在多个键，则需要合并所有的键（求并集），然后计算其基数。

上述讲到了分桶统计来消除误差，hyperloglog在误差方面对上述只取最大值平均的方法做了很多优化，具体优化部分可以参考[解读Cardinality Estimation算法（第四部分：HyperLogLog Counting及Adaptive Counting）](https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iv.html)。

#### 7.4.4 合并hyperloglog键

Redis提供了下面的命令来合并多个hyperloglog键。（源码部分就省略了）

```cpp
PFMERGE destkey sourcekey [sourcekey ...]
```

#### 7.4.5 Redis中部分API函数

```cpp
int hllPatLen(unsigned char *ele, size_t elesize, long *regp);
int hllDenseSet(uint8_t *registers, long index, uint8_t count);
int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize);
void hllDenseRegHisto(uint8_t *registers, int* reghisto);
int hllSparseToDense(robj *o);
int hllSparseSet(robj *o, long index, uint8_t count);
int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize);
void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto);
void hllRawRegHisto(uint8_t *registers, int* reghisto);
double hllSigma(double x);
double hllTau(double x);
uint64_t hllCount(struct hllhdr *hdr, int *invalid);
int hllAdd(robj *o, unsigned char *ele, size_t elesize);
robj *createHLLObject(void);
int hllMerge(uint8_t *max, robj *hll);
int isHLLObjectOrReply(client *c, robj *o);
```



### 7.5 hyperloglog小结

一开始以为hyperloglog是Redis的日志部分的实现，后来才发现，跟日志半毛钱的关系都没有。对于密集存储和稀疏存储，能够大大节约内存，后续有时间还是要详细的理一理实现思路。关于基数统计，各位可以参考下面几篇博客。

- [解读Cardinality Estimation算法（第一部分：基本概念）](https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-i.html)
- [解读Cardinality Estimation算法（第二部分：Linear Counting）](https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-ii.html)
- [解读Cardinality Estimation算法（第三部分：LogLog Counting）](https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iii.html)
- [解读Cardinality Estimation算法（第四部分：HyperLogLog Counting及Adaptive Counting）](http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-iv.html)

**Q:为什么一个hyperloglog键的大小固定为12KB？**

**A:**Redis的hyperloglog结构中，card数组为64位bit，理论上可以存储近`2^64`个值。以密集表示模式为例：

Redis规定分桶个数为16384个，每一个桶内的数据采用6bit大小来存放

> 注意：Redis此处存放的不是该元素，而是存放第一次出现“1”的位置的值，6bit可以表示0~64位，即可以支持`2^64`个基数。

registers部分占用内存为（16384*6+7）/8 = 12288个字节，另外加上HLL结构的头占用了16个字节，加起来一共12304个字节，也就是说一个hyperloglog键占用了12KB左右的大小，最多可以计算`2^64`个不同元素的基数。



转载来源

- https://zhuanlan.zhihu.com/p/26562588

- https://blog.csdn.net/terence1212/article/details/53543801





## 8. 整数集合（有序列表）

> 源码位置：intset.h 和 intset.c

### 8.1 数据结构

```cpp
/* Note that these encodings are ordered, so:
 * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))

// 以下所有数据在内存中使用小端存储
typedef struct intset {
    uint32_t encoding;          // 编码方式，见上述三种类型 INTSET_ENC_INT**
    uint32_t length;            // 长度
    int8_t contents[];          // 数据内容
} intset;
```

### 8.2 常用函数

```cpp
// 内部函数
static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos);     // 二分查找value的位置
// 外部API函数
intset *intsetNew(void);                                                   // 初始化intset*
intset *intsetAdd(intset *is, int64_t value, uint8_t *success);            // 插入value
intset *intsetRemove(intset *is, int64_t value, int *success);             // 删除value
uint8_t intsetFind(intset *is, int64_t value);                             // 查找value，调用intsetSearch
int64_t intsetRandom(intset *is);                                          // 调用rand()，随机获得元素
uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);               // 获取post位置的元素
uint32_t intsetLen(const intset *is);                                      // 整数集合的长度
size_t intsetBlobLen(intset *is);                                          // 获取集合的字节长度
int intsetValidateIntegrity(const unsigned char *is, size_t size, int deep); // 检查整数集合是否合法
// deep = 0：只检查encoding、length、
// deep = 1：检查encoding、length、content数组有序、content数组元素不重复
```

### 8.3 底层实现

#### 8.3.1：插入

```cpp
/* Insert an integer in the intset */
// [OUT]success: 1成功，0失败
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);   // 获取数据编码类型：
    uint32_t pos;
    if (success) *success = 1;

    // is->encoding存入的时候调用了一次intrev32ifbe转换成小端数据
    // 读出来的时候，也要再调用一次intrev32ifbe转换回去
    if (valenc > intrev32ifbe(is->encoding)) {
        // 插入值的取值范围 > 当前encoding取值范围，逐个升级所有数据（升级数据类型），算法复杂度：O(N)
        return intsetUpgradeAndAdd(is,value);
    } else {
        // 二分查找value的位置
        if (intsetSearch(is,value,&pos)) {
            // 数据已经存在，插入新值失败
            if (success) *success = 0;
            return is;
        }

        // 新的数组长度，+1表示新增的一个元素
        is = intsetResize(is,intrev32ifbe(is->length)+1); 
        // pos及其之后的数据往后移动一个位置，intsetMoveTail中调用一次memmove函数,算法复杂度O(1)
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }
    
    // 写入值
    _intsetSet(is,pos,value);
    // 更新长度
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

> 升级和降级：
>
> - 升级的好处显而易见，在数据的值比较小的时候，可以节省内存空间，同时兼容数据值较大的情况
> - 降级：有序整数集合一旦升级，不支持降级

> 时间复杂度：
>
> - 如果新元素是原来的数据类型存不下去的数据（溢出），逐个更新所有数据，复杂度O(N)
> - 如果新元素原来的数据类型能存下，只需要调用一次memmove移动内存数据，复杂度O(1)

#### 8.3.2：删除

```cpp
/* Delete integer from intset */
// [OUT]success: 1成功，0失败
intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 0;

    // value在允许范围内，二分查找value的位置
    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {
        uint32_t len = intrev32ifbe(is->length);

        if (success) *success = 1;

        // pos之后的数据往前移动一个位置，intsetMoveTail中调用一次memmove函数,算法复杂度O(1)
        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
        // 释放了一个元素，需要调整内存大小和数组长度
        is = intsetResize(is,len-1);
        is->length = intrev32ifbe(len-1);
    }
    return is;
}
```

> 时间复杂度：
>
> - 二分查找元素不存在：直接返回失败，复杂度：O(logN)
> - 二分查找元素存在，需要再调用一次memmove函数移动内存数据，复杂度：O(logN)

### 8.4 一些疑问

> **为什么有序整数集合中要用小端数据存储？**
>
> RDB持久化模式下，intset、ziplist在写入RDB文件中的时候，会直接将对应内存中的数据直接写入到文件中，中间没有任何转换，因为intset、ziplist是保存在连续内存块中的，不需要额外处理。而像list dict skiplist这些结构中的数据是使用指针关联起来的，无法直接写人到文件中，需要额外的转换操作，具体就是将其中的数据转换为字符串写入到文件中。这样以来，如果我们在其他机器上加载RDB文件恢复数据时，就不需要考虑list dict skiplist这些数据的大小端问题，因为他们的数据是以字符串存储的，而intset、ziplist是以整个结构的二进制存储的，需要考虑大小端的问题。
>
> 作者：iEternity
> 链接：https://www.zhihu.com/question/65629444/answer/693414175
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 9. 压缩列表

> 源码位置：ziplist.h和ziplist.c

### 9.1 数据结构

```cpp
/* Each entry in the ziplist is either a string or an integer. */
typedef struct {
    unsigned char *sval;        // 字符数组的指针
    unsigned int slen;          // 节点字节长度
    long long lval;             // 整数类型值，如果为整数时，sval为NULL
} ziplistEntry;

/* 记录压缩列表节点的数据结构
 * 注意，实际上节点的数据并不是这么存储的，这只是为了更方便的读取数据
*/
typedef struct zlentry {
    // 上个节点的 len字段 的字节长度
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
    // 上个节点的 数据内容 的长度
    unsigned int prevrawlen;     /* Previous entry len. */
    // 当前节点的 len字段 的长度
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
    // 当前节点的 数据内容 的长度
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
    unsigned int headersize;     /* prevrawlensize + lensize. */
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
                                    immediate integers this can assume a range
                                    of values and must be range-checked. */
    unsigned char *p;            /* Pointer to the very start of the entry, that
                                    is, this points to prev-entry-len field. */
} zlentry;
```



### 9.2 设计说明

#### 9.2.1 压缩列表结构

![image-20210829152305394](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/image-20210829152305394-1631041229343.png)

> 压缩列表没有定义成一个结构体的形式，是用char*的形式，参看`unsigned char *ziplistNew(void)`的返回值可以得知。另外，这种设计方式和sds的设计类似，sds本质上也是`char*`类型，指向的是动态数组的字符串数组的指针。
>
> 字段含义：
>
> - zlbytes（uint32_t）：总占用的内存字节数
> - zltail（uint32_t）：记录 压缩列表的起始地址 到 列表表尾节点距离 有多少字节
> - zllen（uint16_t）：压缩列表包含的节点数量
> - entryX（`ziplistEntry`）：列表节点
> - zlend（uint8_t）：结束标记符



分析始化压缩列表初的源码，了解压缩列表的结构定义：

```cpp
// 压缩列表头部：2个uint32_t分别表示“字节数”和“列表尾部偏移量”，1个uint16_t表示“节点数量”
#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
// 压缩列表指针，同时也是zlbytes数据的指针
#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
// 压缩列表指针偏移sizeof(uint32_t)，同时也是zltail数据的指针
#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
// 压缩列表指针偏移2*sizeof(uint32_t)，同时也是zllen数据的指针，如果返回值为UINT16_MAX，表示超出uint16_t能表达的范围，必须遍历列表才能知道列表节点数
#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))

#define ZIPLIST_END_SIZE        (sizeof(uint8_t))                          // ZIP_END的大小
#define ZIP_END 255                                                        // 0xFF，特定的结束标记符

/* 创建空的压缩列表 */
unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;   // 字节大小
    unsigned char *zl = zmalloc(bytes);                          // 列表指针
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);                     // 初始化zlbytes
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE); // 初始化zltail
    ZIPLIST_LENGTH(zl) = 0;                                      // 初始化zllen
    zl[bytes-1] = ZIP_END;                                       // 初始化结束标记符
    return zl;
}
```



#### 9.2.2 压缩列表节点构成

每个压缩列表节点都由 `previous_entry_length` 、 `encoding` 、 `content` 三个部分组成， 如图 7-4 所示。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c330140d.png)



每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种（表 7-2 字节数组编码）：

| `content` **属性保存的值**                    | **编码长度** | **编码**                                       |
| --------------------------------------------- | ------------ | ---------------------------------------------- |
| 长度小于等于 `63 (2^6-1)` 字节的字节数组      | `1` 字节     | `00bbbbbb`                                     |
| 长度小于等于 `16383 (2^14-1)` 字节的字节数组  | `2` 字节     | `01bbbbbb xxxxxxxx`                            |
| 长度小于等于 `4294967295 (2^32-1)` 的字节数组 | `5` 字节     | `10****** aaaaaaaa bbbbbbbb cccccccc dddddddd` |

而整数值则可以是以下六种长度的其中一种（表 7-3 整数编码）：

| `content` **属性保存的值**    | 编码长度 | **编码**   |
| ----------------------------- | -------- | ---------- |
| `int16_t` 类型的整数          | `1` 字节 | `11000000` |
| `int32_t` 类型的整数          | `1` 字节 | `11010000` |
| `int64_t` 类型的整数          | `1` 字节 | `11100000` |
| `24` 位有符号整数             | `1` 字节 | `11110000` |
| `8` 位有符号整数              | `1` 字节 | `11111110` |
| `4` 位长(`0` 和`12` 之间的值) | `1` 字节 | `1111xxxx` |

> 使用`4位长`这一编码的节点没有相应的 `content` 属性， 因为编码本身的 `xxxx` 四个位已经保存了一个介于 `0` 和`12` 之间的值， 所以它无须 `content` 属性。





##### 9.2.2.1 previous_entry_length

节点的 `previous_entry_length` 属性以字节为单位， 记录了压缩列表中前一个节点的长度。

`previous_entry_length` 属性的长度可以是 `1` 字节或者 `5` 字节：

- 如果前一节点的长度小于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `1` 字节： 前一节点的长度就保存在这一个字节里面。
- 如果前一节点的长度大于等于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `5` 字节： 其中属性的第一字节会被设置为 `0xFE`（十进制值 `254`）， 而之后的四个字节则用于保存前一节点的长度。

图 7-5 展示了一个包含一字节长 `previous_entry_length` 属性的压缩列表节点， 属性的值为 `0x05` ， 表示前一节点的长度为 `5` 字节。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c341e72d-163054323996926.png)

图 7-6 展示了一个包含五字节长 `previous_entry_length` 属性的压缩节点， 属性的值为 `0xFE00002766` ， 其中值的最高位字节 `0xFE` 表示这是一个五字节长的 `previous_entry_length` 属性， 而之后的四字节 `0x00002766` （十进制值 `10086` ）才是前一节点的实际长度。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c358c906-16305811498784.png)

> `previous_entry_length` 属性在读取压缩列表节点的使用用于界定数据边界，在遍历节点时，可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址

例如，如果我们有一个指向当前节点起始地址的指针 `c` ， 那么我们只要用指针 `c` 减去当前节点 `previous_entry_length` 属性的值， 就可以得出一个指向前一个节点起始地址的指针 `p` ， 如图 7-7 所示。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c36a9d1e-163054358574629.png)

##### 9.2.2.2 encoding

节点的 `encoding` 属性记录了节点的 `content` 属性所保存数据的类型以及长度：

- 一字节、两字节或者五字节长， 值的最高位为 `00` 、 `01` 或者 `10` 的是字节数组编码： 这种编码表示节点的 `content` 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；
- 一字节长， 值的最高位以 `11` 开头的是整数编码： 这种编码表示节点的 `content` 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；

上表 7-2 记录了所有可用的字节数组编码， 上而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 `_` 表示留空， 而 `b` 、 `x` 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。

编码类型的宏定义：

```c
/* Different encoding/length possibilities */
#define ZIP_STR_06B (0 << 6)
#define ZIP_STR_14B (1 << 6)
#define ZIP_STR_32B (2 << 6)
#define ZIP_INT_16B (0xc0 | 0<<4)
#define ZIP_INT_32B (0xc0 | 1<<4)
#define ZIP_INT_64B (0xc0 | 2<<4)
#define ZIP_INT_24B (0xc0 | 3<<4)
#define ZIP_INT_8B 0xfe
```



##### 9.2.2.3 content

节点的 `content` 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 `encoding` 属性决定。

图 7-9 展示了一个保存字节数组的节点示例：

- 编码的最高两位 `00` 表示节点保存的是一个字节数组；
- 编码的后六位 `001011` 记录了字节数组的长度 `11` ；
- `content` 属性保存着节点的值 `"hello world"` 。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c4228d21.png)



图 7-10 展示了一个保存整数值的节点示例：

- 编码 `11000000` 表示节点保存的是一个 `int16_t` 类型的整数值；
- `content` 属性保存着节点的值 `10086` 。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c4312fbc-163054379872932.png)

### 9.3 连锁更新

前面说过， 每个节点的 `previous_entry_length` 属性都记录了前一个节点的长度：

- 如果前一节点的长度小于 `254` 字节， 那么 `previous_entry_length` 属性需要用 `1` 字节长的空间来保存这个长度值。
- 如果前一节点的长度大于等于 `254` 字节， 那么 `previous_entry_length` 属性需要用 `5` 字节长的空间来保存这个长度值。

现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 `250` 字节到 `253` 字节之间的节点 `e1` 至 `eN` ， 如图 7-11 所示。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c92165a8.png)

因为 `e1` 至 `eN` 的所有节点的长度都小于 `254` 字节， 所以记录这些节点的长度只需要 `1` 字节长的 `previous_entry_length` 属性， 换句话说，`e1` 至 `eN` 的所有节点的 `previous_entry_length` 属性都是 `1` 字节长的。

这时， 如果我们将一个长度大于等于 `254` 字节的新节点 `new` 设置为压缩列表的表头节点， 那么 `new` 将成为 `e1` 的前置节点， 如图 7-12 所示。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c930ab24.png)

因为 `e1` 的 `previous_entry_length` 属性仅长 `1` 字节， 它没办法保存新节点 `new` 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将`e1` 节点的 `previous_entry_length` 属性从原来的 `1` 字节长扩展为 `5` 字节长。

现在， 麻烦的事情来了 —— `e1` 原本的长度介于 `250` 字节至 `253` 字节之间， 在为 `previous_entry_length` 属性新增四个字节的空间之后， `e1`的长度就变成了介于 `254` 字节至 `257` 字节之间， 而这种长度使用 `1` 字节长的 `previous_entry_length` 属性是没办法保存的。

因此， 为了让 `e2` 的 `previous_entry_length` 属性可以记录下 `e1` 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 `e2` 节点的`previous_entry_length` 属性从原来的 `1` 字节长扩展为 `5` 字节长。

正如扩展 `e1` 引发了对 `e2` 的扩展一样， 扩展 `e2` 也会引发对 `e3` 的扩展， 而扩展 `e3` 又会引发对 `e4` 的扩展……为了让每个节点的`previous_entry_length` 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 `eN` 为止。

Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c9411c63.png)

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c9562866.png)

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c968ab45.png)

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c97d30cf.png)

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c99143df.png)

除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。

考虑图 7-14 所示的压缩列表， 如果 `e1` 至 `eN` 都是大小介于 `250` 字节至 `253` 字节的节点， `big` 节点的长度大于等于 `254` 字节（需要 `5` 字节的 `previous_entry_length` 来保存）， 而 `small` 节点的长度小于 `254` 字节（只需要 `1` 字节的 `previous_entry_length` 来保存）， 那么当我们将 `small` 节点从压缩列表中删除之后， 为了让 `e1` 的 `previous_entry_length` 属性可以记录 `big` 节点的长度， 程序将扩展 `e1` 的空间， 并由此引发之后的连锁更新。

![img](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c9a98f6f.png)

因为连锁更新在最坏情况下需要对压缩列表执行 `N` 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。

要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：

- 首先， 压缩列表里要恰好有多个连续的、长度介于 `250` 字节至 `253` 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；
- 其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；

因为以上原因， `ziplistPush` 等命令的平均复杂度仅为 ![O(N)](%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.assets/2015-09-13_55f51c9fd4b9d.png) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。



### 9.4 API函数

```cpp
unsigned char *ziplistNew(void);          // 初始化压缩列表
unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);  // 合并链表
unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, 
                           unsigned int slen, int where);           // 并将新节点添加到表头/表尾, O(N^2)
unsigned char *ziplistIndex(unsigned char *zl, int index);          // 返回节点，如果是负数表示到数，O（N）
unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);    // 返回给定节点的下一个节点，O(1)
unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);    // 返回给定节点的上一个节点，O(1)
unsigned int   ziplistGet(unsigned char *p, unsigned char **sval,
                          unsigned int *slen, long long *lval);     // 获取节点值。O(1)
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p,
                             unsigned char *s, unsigned int slen);  // 将值s,slen的节点插入p后面，O(N^2)
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p); // 删除节点，O(N^2),可能连锁更新
unsigned char *ziplistDeleteRange(unsigned char *zl, int index,
                                  unsigned int num);                // 删除节点，O(N^2),可能连锁更新
unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p,
                              unsigned char *s, unsigned int slen); //  替换节点，1次delete + 1次insert
unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen); // 对比节点值和给定值
unsigned char *ziplistFind(unsigned char *zl, unsigned char *p,unsigned char *vstr,
                           unsigned int vlen, unsigned int skip);   // 查找节点（每间隔skip节点查找）
unsigned int ziplistLen(unsigned char *zl); // 获取长度，如果长度<UINT16_MAX(65535)，直接读zllen，否则需要遍历列表O(N)
size_t ziplistBlobLen(unsigned char *zl);   // 返回zlbytes属性
void ziplistRepr(unsigned char *zl);        // 打印压缩列表 描述信息
typedef int (*ziplistValidateEntryCB)(unsigned char* p, void* userdata);

void ziplistRandomPair(unsigned char *zl, unsigned long total_count,
                       ziplistEntry *key, ziplistEntry *val); // 从列表中随机获得一组键值
void ziplistRandomPairs(unsigned char *zl, unsigned int count,
                        ziplistEntry *keys, ziplistEntry *vals); // 随机获取count组键值，可能重复

unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count,
                       ziplistEntry *keys, ziplistEntry *vals);  // 随机获取count组键值，不重复

// 检查压缩列表zl，deep=0只检查头部，deep=1检查所有节点
int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,
            ziplistValidateEntryCB entry_cb, void *cb_userdata); 

  
```



9.2、9.3中大量内容来自：

- https://www.w3cschool.cn/hdclil/avdu2ozt.html

